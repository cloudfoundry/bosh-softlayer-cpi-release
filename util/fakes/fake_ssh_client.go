// This file was generated by counterfeiter
package fakes

import (
	"io"
	"sync"

	"github.com/cloudfoundry/bosh-softlayer-cpi/util"
)

type FakeSshClient struct {
	ExecCommandStub        func(username string, password string, ip string, command string) (string, error)
	execCommandMutex       sync.RWMutex
	execCommandArgsForCall []struct {
		username string
		password string
		ip       string
		command  string
	}
	execCommandReturns struct {
		result1 string
		result2 error
	}
	DownloadStub        func(username, password, ip, srcFile string, destination io.Writer) error
	downloadMutex       sync.RWMutex
	downloadArgsForCall []struct {
		username    string
		password    string
		ip          string
		srcFile     string
		destination io.Writer
	}
	downloadReturns struct {
		result1 error
	}
	DownloadFileStub        func(username string, password string, ip string, srcFile string, destFile string) error
	downloadFileMutex       sync.RWMutex
	downloadFileArgsForCall []struct {
		username string
		password string
		ip       string
		srcFile  string
		destFile string
	}
	downloadFileReturns struct {
		result1 error
	}
	UploadStub        func(username, password, ip string, source io.Reader, destFile string) error
	uploadMutex       sync.RWMutex
	uploadArgsForCall []struct {
		username string
		password string
		ip       string
		source   io.Reader
		destFile string
	}
	uploadReturns struct {
		result1 error
	}
	UploadFileStub        func(username string, password string, ip string, srcFile string, destFile string) error
	uploadFileMutex       sync.RWMutex
	uploadFileArgsForCall []struct {
		username string
		password string
		ip       string
		srcFile  string
		destFile string
	}
	uploadFileReturns struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSshClient) ExecCommand(username string, password string, ip string, command string) (string, error) {
	fake.execCommandMutex.Lock()
	fake.execCommandArgsForCall = append(fake.execCommandArgsForCall, struct {
		username string
		password string
		ip       string
		command  string
	}{username, password, ip, command})
	fake.recordInvocation("ExecCommand", []interface{}{username, password, ip, command})
	fake.execCommandMutex.Unlock()
	if fake.ExecCommandStub != nil {
		return fake.ExecCommandStub(username, password, ip, command)
	} else {
		return fake.execCommandReturns.result1, fake.execCommandReturns.result2
	}
}

func (fake *FakeSshClient) ExecCommandCallCount() int {
	fake.execCommandMutex.RLock()
	defer fake.execCommandMutex.RUnlock()
	return len(fake.execCommandArgsForCall)
}

func (fake *FakeSshClient) ExecCommandArgsForCall(i int) (string, string, string, string) {
	fake.execCommandMutex.RLock()
	defer fake.execCommandMutex.RUnlock()
	return fake.execCommandArgsForCall[i].username, fake.execCommandArgsForCall[i].password, fake.execCommandArgsForCall[i].ip, fake.execCommandArgsForCall[i].command
}

func (fake *FakeSshClient) ExecCommandReturns(result1 string, result2 error) {
	fake.ExecCommandStub = nil
	fake.execCommandReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSshClient) Download(username string, password string, ip string, srcFile string, destination io.Writer) error {
	fake.downloadMutex.Lock()
	fake.downloadArgsForCall = append(fake.downloadArgsForCall, struct {
		username    string
		password    string
		ip          string
		srcFile     string
		destination io.Writer
	}{username, password, ip, srcFile, destination})
	fake.recordInvocation("Download", []interface{}{username, password, ip, srcFile, destination})
	fake.downloadMutex.Unlock()
	if fake.DownloadStub != nil {
		return fake.DownloadStub(username, password, ip, srcFile, destination)
	} else {
		return fake.downloadReturns.result1
	}
}

func (fake *FakeSshClient) DownloadCallCount() int {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	return len(fake.downloadArgsForCall)
}

func (fake *FakeSshClient) DownloadArgsForCall(i int) (string, string, string, string, io.Writer) {
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	return fake.downloadArgsForCall[i].username, fake.downloadArgsForCall[i].password, fake.downloadArgsForCall[i].ip, fake.downloadArgsForCall[i].srcFile, fake.downloadArgsForCall[i].destination
}

func (fake *FakeSshClient) DownloadReturns(result1 error) {
	fake.DownloadStub = nil
	fake.downloadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSshClient) DownloadFile(username string, password string, ip string, srcFile string, destFile string) error {
	fake.downloadFileMutex.Lock()
	fake.downloadFileArgsForCall = append(fake.downloadFileArgsForCall, struct {
		username string
		password string
		ip       string
		srcFile  string
		destFile string
	}{username, password, ip, srcFile, destFile})
	fake.recordInvocation("DownloadFile", []interface{}{username, password, ip, srcFile, destFile})
	fake.downloadFileMutex.Unlock()
	if fake.DownloadFileStub != nil {
		return fake.DownloadFileStub(username, password, ip, srcFile, destFile)
	} else {
		return fake.downloadFileReturns.result1
	}
}

func (fake *FakeSshClient) DownloadFileCallCount() int {
	fake.downloadFileMutex.RLock()
	defer fake.downloadFileMutex.RUnlock()
	return len(fake.downloadFileArgsForCall)
}

func (fake *FakeSshClient) DownloadFileArgsForCall(i int) (string, string, string, string, string) {
	fake.downloadFileMutex.RLock()
	defer fake.downloadFileMutex.RUnlock()
	return fake.downloadFileArgsForCall[i].username, fake.downloadFileArgsForCall[i].password, fake.downloadFileArgsForCall[i].ip, fake.downloadFileArgsForCall[i].srcFile, fake.downloadFileArgsForCall[i].destFile
}

func (fake *FakeSshClient) DownloadFileReturns(result1 error) {
	fake.DownloadFileStub = nil
	fake.downloadFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSshClient) Upload(username string, password string, ip string, source io.Reader, destFile string) error {
	fake.uploadMutex.Lock()
	fake.uploadArgsForCall = append(fake.uploadArgsForCall, struct {
		username string
		password string
		ip       string
		source   io.Reader
		destFile string
	}{username, password, ip, source, destFile})
	fake.recordInvocation("Upload", []interface{}{username, password, ip, source, destFile})
	fake.uploadMutex.Unlock()
	if fake.UploadStub != nil {
		return fake.UploadStub(username, password, ip, source, destFile)
	} else {
		return fake.uploadReturns.result1
	}
}

func (fake *FakeSshClient) UploadCallCount() int {
	fake.uploadMutex.RLock()
	defer fake.uploadMutex.RUnlock()
	return len(fake.uploadArgsForCall)
}

func (fake *FakeSshClient) UploadArgsForCall(i int) (string, string, string, io.Reader, string) {
	fake.uploadMutex.RLock()
	defer fake.uploadMutex.RUnlock()
	return fake.uploadArgsForCall[i].username, fake.uploadArgsForCall[i].password, fake.uploadArgsForCall[i].ip, fake.uploadArgsForCall[i].source, fake.uploadArgsForCall[i].destFile
}

func (fake *FakeSshClient) UploadReturns(result1 error) {
	fake.UploadStub = nil
	fake.uploadReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSshClient) UploadFile(username string, password string, ip string, srcFile string, destFile string) error {
	fake.uploadFileMutex.Lock()
	fake.uploadFileArgsForCall = append(fake.uploadFileArgsForCall, struct {
		username string
		password string
		ip       string
		srcFile  string
		destFile string
	}{username, password, ip, srcFile, destFile})
	fake.recordInvocation("UploadFile", []interface{}{username, password, ip, srcFile, destFile})
	fake.uploadFileMutex.Unlock()
	if fake.UploadFileStub != nil {
		return fake.UploadFileStub(username, password, ip, srcFile, destFile)
	} else {
		return fake.uploadFileReturns.result1
	}
}

func (fake *FakeSshClient) UploadFileCallCount() int {
	fake.uploadFileMutex.RLock()
	defer fake.uploadFileMutex.RUnlock()
	return len(fake.uploadFileArgsForCall)
}

func (fake *FakeSshClient) UploadFileArgsForCall(i int) (string, string, string, string, string) {
	fake.uploadFileMutex.RLock()
	defer fake.uploadFileMutex.RUnlock()
	return fake.uploadFileArgsForCall[i].username, fake.uploadFileArgsForCall[i].password, fake.uploadFileArgsForCall[i].ip, fake.uploadFileArgsForCall[i].srcFile, fake.uploadFileArgsForCall[i].destFile
}

func (fake *FakeSshClient) UploadFileReturns(result1 error) {
	fake.UploadFileStub = nil
	fake.uploadFileReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSshClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.execCommandMutex.RLock()
	defer fake.execCommandMutex.RUnlock()
	fake.downloadMutex.RLock()
	defer fake.downloadMutex.RUnlock()
	fake.downloadFileMutex.RLock()
	defer fake.downloadFileMutex.RUnlock()
	fake.uploadMutex.RLock()
	defer fake.uploadMutex.RUnlock()
	fake.uploadFileMutex.RLock()
	defer fake.uploadFileMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeSshClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ util.SshClient = new(FakeSshClient)
